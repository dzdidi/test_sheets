\chapter{Contributions}
\label{sec:contributions}
For particular implementation of Test Sheets paradigm were developed conventions conventions described below. 
\section{Conventions}
\label{sec:conventions}

Following conventions should be followed for Test Sheet passed verification.

\textbf{General:}
\begin{itemize}
\item Number of columns within one TS should not exceed 26 columns (from A to Z);
\item Invocation delimiters must be allocated within single column the (aligned to the longest row);
\item References to the columns with expected returns columns will take as value actual return value obtained from method execution;
\item Files extensions should be .xlsx\\
\end{itemize}

\textbf{ Basic Test Sheets} 
\begin{itemize}
\item A1 cell(optional) - description of the test case;
\item A2 cell - module under testing with an extension (.js);
\item A3..n - name of the class/object under the test;
\item B3..n - name of the method from representative class (same row) under the test;
\item C2..n to Invocation Column - input parameters for representative method (same row) under the test;
\item Invocation Column - the column for separation of input values from expected output value(s) filled with | (pipe)(for comparison by scheme and data types) || (two pipes)(for deep comparison - by scheme, data types and values) as a cells values until the last line which includes objects under tests;
\item Expected Return - column(s) after invocation line.\\
\end{itemize}

%\textbf{ Non-Linear Test Sheets}
%Same convention as for Basic Test Sheets plus following conventions for Behaviour Specification:
%\begin{itemize}
%\item N-th row - the row for separation of test definitions from the test behaiour. Filled with \_ (underscore) until the last column of expect values (excluding invocation column)
%\item N+1-th row - Starting state. Starts with -> following space separated integers which represent testing steps which should be executed first;
%\item N+2-th row - Intermediate state. Each cell of this row should satisfy following syntax requirements: guard ->following space separated integers which represent testing steps which should be executed if condition within guard is true. One of which should be equal to N+3 which represents the final state;
%\item N+3 - Final state. Empty line showing end of testing process.
%\end{itemize}
%Syntax for guard: [\#N <condition> <value | link to the cell>], where:
%\#N - number of times row N has already been executed within current test;
%<condition> - conditional operator (>, >=, <, <=, ==, !=)
%<value | link to the cell> - value or link to the cell with value which should be compared.\\

\textbf{ Parameterized and Higher-Order Test Sheets}
Lower order test sheets can belong to Basic of Non-Linear types of Test Sheets and respectively follow conventions, with next additional option:
\begin{itemize}
\item Input and/or output cells can contain parameters ?[B-Z]+ which represent the value of cells within the representative column of Higher-Order Test Sheet
\item Rows 1 and 2 should follow conventions for Basic Test Sheet;
\item Cells starting from second row inside of [B-Z] columns should contain values which will replace parameters inside of Parameterized Test Sheet.
\end{itemize}

 \section{Use Case}
 definition (possibly in tabular form)


\begin{itemize}
\item Test Sheets defined by users (clients or employees without development background).
\item Tests themselves will be applied for identification of layout changes on a target page before any interaction will appear to avoid errors and minimize the time of scripts correction.
\end{itemize}
 
\textbf{Execution stages:}
\begin{itemize}
\item Automated transformation of Test Sheets into JavaScript tests;
\item Scheduled task for running tests on web pages;
\item Developer notification regarding failing test.
\end{itemize}

The program run by user 
%The implemented program is running as a crown job which is executing JS files generated from xlsx Test Sheets. Each JS file invokes scrapping script via Command Line Interface which in turn performs communication to Bank's web page. Results of script execution are compared with expected outputs from Test Sheet using a callback function. Result of comparison is written to LogStash and original Test Sheet.


\section{Architecture} 
This system implements Pipe-and-Filter Architecture. \cite{Dooley} \cite{nodejsbook}
%with some external complexity included in to piping mechanisms with application of pipeing patterns. 

"In a pipe-and-filter style architecture, the computations components are called filters and they act as transducers that take input, transform it according to one or mode algorithms, and then output the result to communications conduit. The input and outputs coduits are called pipes.\\
The filters must be intedependent components. [...] The clasic example of pipe-and-filter architectural style is the Unix shell[...]"\cite{Dooley}.


\section{Design and Implementation}
Consists of two streams Reader and Writer both streams are in object mode.

The system's information workflow described with following explanatory Test Sheet:\\
\begin{tabular}[h]{| c | l | l | l | l | l | l | }
	\hline
	 \  & A & B & C & D & E & F \\
		\hline
	1 & get Accounts & \ & \ & \ & \ & \ \\
		\hline
	2 & BankAustria & \ & \ & \ & \ & \  \\
		\hline
	3 & BankAustria & login & $<$credentials object$>$ & $<$pin object$>$ & $|$ & \{...\} \\
		\hline
	4 & BankAustria & getAccounts & $<$credentials object$>$ & \ & $||$ & \{...\} \\
	\hline
\end{tabular}

\subsection{Reader}
%Reader accepts directory with Test Sheets (*.xlsx files) as an input parameter and returns a Schema object with a following structure for all directory entries to the standard stream interface.


On a lower level Reader stream consists of two combined streams (streams combination pattern used);

First stream takes input as a directrory and returns list of absolute paths to all files within provided directory (including nested folders);
Second stream accepts output of a first stream and for all .xlsx files obtains its schema invoking function from schema\_maker library and as an output returns object with absolute path to the Test Sheet file with file content returned by reading with object returned by reading file (object pool pattern) with \textit{xlsx} library (\url{https://www.npmjs.com/package/xlsx}) and scheme created by schema\_maker library.\\
\textbf{Schema structure for expample Test Sheet:}
\begin{itemize}
	\item pathToFile: 'absloute/path/to/test/sheet/file';
	\item testsheet: \{ $<$ object returned by xlsx library $>$\};
	\item schema:
		\subitem description: 'get Accounts',
	    \subitem moduleUnderTest: 'BankAustria',
	    \subitem objectsUnderTest: ['A3', 'A4'],
	    \subitem methodsUnderTest: ['B3', 'B4'],
	    \subitem inputs: ['C3', 'C4', 'D3],
    	\subitem outputs: ['F3', 'F4'],
    	\subitem invocations: ['E3', 'E4'],
\end{itemize}

\paragraph{Correspondence to design principles:}
\begin{itemize}
	\item Closing - stream is closed over file extension, schema\_maker - object structure returned by 	\textit{xlsx} library;
	\item Code to Interface - stream obtains and returns values via standard stream interface, call to file system made via standard nodeJS File System stream interface;
	\item Do not Repeat Yourself - no code duplication;
	\item Single Responsibility Principle - can be changed only due to the change of input type;
	\item Open Close Principle - new pipes can be added in a single place;
	\item Liscov Substitution Principle - no inherited objects used;
	\item Interface Segregation Principle - no dependency on redundant methods;
	\item Dependency Inversion Principle - higher level module index.js does not depend on current library
	\item Least Knowledge Principle - communication to interfaces and invocation of used library;
	\item Loose Coupling Principle - standard interfaces;
\end{itemize}

%\textbf{Design principles implication:}
%\begin{itemize}
%\item  S. - Single Responsibility Principle - can be changed only due to the change of input type
%\item  O. - Open Close Principle - new pipes can be added in a single place
%\item  L. - Liscov Substitution Principle - no inheritance
%\item  I. - Interface Segregation Principle - Stream interface / File System interface
%\item  D. - Dependency Inversion Principle - Higgher level module index.js does not depend on current library

%Writer structure:\\

%\end{itemize}
\subsection{Writer}