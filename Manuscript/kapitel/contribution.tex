\chapter{Contributions}
\label{sec:contributions}
For particular implementation of Test Sheets paradigm were developed conventions conventions described below. 
\section{Requirements analysis}
This section describes and analyses requirements differences defined by Test Sheets concept and introduced by figo GmbH.

Test Sheets were originally designed for test definitions of  OOP languages. And all available examples describes tests definitions for Java Classes. While figo GmbH case requires implementation of tests for nodeJS/casperJS, which are based on JavaScript - Object Oriented, imperative, Functional Oriented programming language with asynchronous information flow. Moreover figo GmbH requires input of test results to be recorded in to LogStash logs database. The execution requirements from figo GmbH are such that tests defined via Test Sheets should be automatically executed in a time manner (every 2 mins or so), while normal software testing is performed on demand.
The figo's requirement for comparison is such that while defining a Test Sheet user should be able to select from two types of comparison: 1) Strict comparison - complete comparison of objects including both properties' structure and their values. 2) Not-Strict comparison - scheme comparison of objects.

(Probably should go to different section)
Scraping scripts implement callback based approach for handling asynchronous data flow. This provides an opportunity to perform result comparison within the custom callback defined on a implementation stage.
Standard convention for callback definitions limitates number of input parameters of a callback (error, data), while comparison requires compare data parameter with expected outputs from Test Sheet. The opportunity to resolve this issue lays in a JavaScript's support of functions as a class citizens, the function implementation of module for comparison and report: module exports function which invoked with single parameters (expected\_output) / ( + script name) and returns function which is used as a callback for scrapping script, this callback function performs comparison and writes its result to TestSheet or logstash depending on environment in which the program was executed

\section{Conventions}
\label{sec:conventions}

Following conventions should be followed for Test Sheet passed verification.

\textbf{General:}
\begin{itemize}
\item Number of columns within one TS should not exceed 26 columns (from A to Z);
\item Invocation delimiters must be allocated within single column the (aligned to the longest row);
\item References to the columns with expected returns columns will take as value actual return value obtained from method execution;
\item Files extensions should be .xlsx\\
\end{itemize}

\textbf{ Basic Test Sheets} 
\begin{itemize}
\item A1 cell(optional) - description of the test case;
\item A2 cell - module under testing with an extension (.js);
\item A3..n - name of the class/object under the test;
\item B3..n - name of the method from representative class (same row) under the test;
\item C2..n to Invocation Column - input parameters for representative method (same row) under the test;
\item Invocation Column - the column for separation of input values from expected output value(s) filled with | (pipe)(for comparison by scheme and data types) || (two pipes)(for deep comparison - by scheme, data types and values) as a cells values until the last line which includes objects under tests;
\item Expected Return - column(s) after invocation line.\\
\end{itemize}

%\textbf{ Non-Linear Test Sheets}
%Same convention as for Basic Test Sheets plus following conventions for Behaviour Specification:
%\begin{itemize}
%\item N-th row - the row for separation of test definitions from the test behaiour. Filled with \_ (underscore) until the last column of expect values (excluding invocation column)
%\item N+1-th row - Starting state. Starts with -> following space separated integers which represent testing steps which should be executed first;
%\item N+2-th row - Intermediate state. Each cell of this row should satisfy following syntax requirements: guard ->following space separated integers which represent testing steps which should be executed if condition within guard is true. One of which should be equal to N+3 which represents the final state;
%\item N+3 - Final state. Empty line showing end of testing process.
%\end{itemize}
%Syntax for guard: [\#N <condition> <value | link to the cell>], where:
%\#N - number of times row N has already been executed within current test;
%<condition> - conditional operator (>, >=, <, <=, ==, !=)
%<value | link to the cell> - value or link to the cell with value which should be compared.\\

\textbf{ Parameterized and Higher-Order Test Sheets}
Lower order test sheets can belong to Basic of Non-Linear types of Test Sheets and respectively follow conventions, with next additional option:
\begin{itemize}
\item Input and/or output cells can contain parameters ?[B-Z]+ which represent the value of cells within the representative column of Higher-Order Test Sheet
\item Rows 1 and 2 should follow conventions for Basic Test Sheet;
\item Cells starting from second row inside of [B-Z] columns should contain values which will replace parameters inside of Parameterized Test Sheet.
\end{itemize}

 \section{Use Case}
 definition (possibly in tabular form)


\begin{itemize}
\item Test Sheets defined by users (clients or employees without development background).
\item Tests themselves will be applied for identification of layout changes on a target page before any interaction will appear to avoid errors and minimize the time of scripts correction.
\end{itemize}
 
\textbf{Execution stages:}
\begin{itemize}
\item Automated transformation of Test Sheets into JavaScript tests;
\item Scheduled task for running tests on web pages;
\item Developer notification regarding failing test.
\end{itemize}

The program run by user 
%The implemented program is running as a crown job which is executing JS files generated from xlsx Test Sheets. Each JS file invokes scrapping script via Command Line Interface which in turn performs communication to Bank's web page. Results of script execution are compared with expected outputs from Test Sheet using a callback function. Result of comparison is written to LogStash and original Test Sheet.


\section{Architecture} 
This system implements Pipe-and-Filter Architecture. \cite{Dooley} \cite{nodejsbook}
%with some external complexity included in to piping mechanisms with application of pipeing patterns. 

"In a pipe-and-filter style architecture, the computations components are called filters and they act as transducers that take input, transform it according to one or mode algorithms, and then output the result to communications conduit. The input and outputs coduits are called pipes.\\
The filters must be intedependent components. [...] The clasic example of pipe-and-filter architectural style is the Unix shell[...]"\cite{Dooley}.


\section{Design and Implementation}
Consists of two streams Reader and Writer both streams are in object mode.

The system's information workflow described with following explanatory Test Sheet:\\
\begin{tabular}[h]{| c | l | l | l | l | l | l | }
	\hline
	 \  & A & B & C & D & E & F \\
		\hline
	1 & get Accounts & \ & \ & \ & \ & \ \\
		\hline
	2 & BankAustria & \ & \ & \ & \ & \  \\
		\hline
	3 & BankAustria & login & $<$credentials object$>$ & $<$pin object$>$ & $|$ & \{...\} \\
		\hline
	4 & BankAustria & getAccounts & $<$credentials object$>$ & \ & $||$ & \{...\} \\
	\hline
\end{tabular}

\subsection{Reader}
%Reader accepts directory with Test Sheets (*.xlsx files) as an input parameter and returns a Schema object with a following structure for all directory entries to the standard stream interface.


On a lower level Reader stream consists of two combined streams (streams combination pattern used);

First stream takes input as a directrory and returns list of absolute paths to all files within provided directory (including nested folders);
Second stream accepts output of a first stream and for all .xlsx files obtains its schema invoking function from schema\_maker library and as an output returns object with absolute path to the Test Sheet file with file content returned by reading with object returned by reading file (object pool pattern) with \textit{xlsx} library (\url{https://www.npmjs.com/package/xlsx}) and scheme created by schema\_maker library.\\
\textbf{Schema structure for expample Test Sheet:}
\begin{itemize}
	\item pathToFile: 'absloute/path/to/test/sheet/file';
	\item testsheet: \{ $<$ object returned by xlsx library $>$\};
	\item schema:
		\subitem description: 'get Accounts',
	    \subitem moduleUnderTest: 'BankAustria',
	    \subitem objectsUnderTest: ['A3', 'A4'],
	    \subitem methodsUnderTest: ['B3', 'B4'],
	    \subitem inputs: ['C3', 'C4', 'D3],
    	\subitem outputs: ['F3', 'F4'],
    	\subitem invocations: ['E3', 'E4'],
\end{itemize}

\paragraph{Correspondence to design principles:}
\begin{itemize}
	\item Closing - stream is closed over file extension, schema\_maker - object structure returned by 	\textit{xlsx} library;
	\item Code to Interface - stream obtains and returns values via standard stream interface, call to file system made via standard nodeJS File System stream interface;
	\item Do not Repeat Yourself - no code duplication;
	\item Single Responsibility Principle - can be changed only due to the change of input type;
	\item Open Close Principle - new pipes can be added in a single place;
	\item Liscov Substitution Principle - no inherited objects used;
	\item Interface Segregation Principle - no dependency on redundant methods;
	\item Dependency Inversion Principle - higher level module index.js does not depend on current library
	\item Least Knowledge Principle - communication to interfaces and invocation of used library;
	\item Loose Coupling Principle - standard interfaces;
\end{itemize}

%\textbf{Design principles implication:}
%\begin{itemize}
%\item  S. - Single Responsibility Principle - can be changed only due to the change of input type
%\item  O. - Open Close Principle - new pipes can be added in a single place
%\item  L. - Liscov Substitution Principle - no inheritance
%\item  I. - Interface Segregation Principle - Stream interface / File System interface
%\item  D. - Dependency Inversion Principle - Higgher level module index.js does not depend on current library

%Writer structure:\\

%\end{itemize}
\subsection{Writer}