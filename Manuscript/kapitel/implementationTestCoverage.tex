\chapter{Design Principles}
\label{chap:design}
The implementation of each part of the system was made with application of Test Driven Development.The testing framework is \textit{mocha} \url{https://mochajs.org/}. For the creation of doublers (mocks, stubs and spies) for object and method was used \textit{sinon.js }\url{http://sinonjs.org/}.

Application of Test Driven Development principles provide better control over the system on a code level but not on design. In the same time Robert Martin \cite{MartinASD} defined symptoms of not agile design as following:
\begin{itemize}
	\item Rigidity - The design is difficult to change;
	\item Fragility - The design is easy to break;
	\item Immobility - The design is difficult to reuse;
	\item Viscosity - It is difficult to do the right thing;
	\item Needless complexity - Overdesign;
	\item Needless repetition - Mouse abuse;
	\item Opacity - Disorganized expression;
\end{itemize}


To avoid creation of such software John Dooley \cite{Dooley} and Rober Maritn \cite{MartinASD} suggested the following principles of agile architecture:
\begin{itemize}
	\item Closing - Encapsulate things in your design that are likely to change.
	\item Code to an Interface - rather then to an implementation. 
	\item Do not repeat yourself - Avoid the duplication of the code.
	\item The Single-Responsibility Principle - A class should has the only one reason to change from the business perspective;
	\item The Open/Closed Principle - Software entities (classes, modules, functions, etc.) should be open for the extension but closed for modification
	\item The Liskov Substitution Principle - Subtypes must be substitutable for their base types.
	\item The Dependency-Inversion Principle - 		
	\begin{itemize}
		\item High-level modules should not depend on low-level modules.  Both should depend on abstractions. 
		\item Abstractions should not depend upon details. Details should depend upon abstractions.
	\end{itemize}
	\item The Interface Segregation Principle - Clients should not be forced to depend on methods they do not use.
	\item Principles of Least Knowledge - Talk to your immediate friends. 
	\item Principle of Loose Coupling - object that interact should be loosely coupled with well-defined intefaces.
\end{itemize}

This principles are suggestional and can not be strictly followed due to their mutually exclusive nature.

\chapter{Conventions}
\label{sec:convnetions}
Following conventions were developed with respect to the requirements defined by figo GmbH and must be followed by Test Sheet for proper work of developed system:
\begin{itemize}
	\item Number of columns within one Test Sheet should not exceed 26 columns (from A to Z);
	\begin{itemize}
		\item \textbf{A1} cell - description of the test case;
		\item \textbf{A2} cell - module under test (folder with index.js or file with js extension);
		\item \textbf{A3..n} cells - name of the class/object under the test;
		\item \textbf{B3..n} cells - name of the method from representative class/object under the test;
		\item \textbf{C2..n} cells to \textbf{Invocation Column}   - input parameters for representative method under the test;
	\end{itemize}
	\item Invocation delimiters must be allocated within the single column (aligned to the longest row);
	\begin{itemize}
		\item \textbf{Invocation Column} - the column for separation of input values from expected output value(s) filled with $|$ (pipe)(for comparison by scheme and data types) $||$ (two pipes)(for deep comparison - by scheme, data types and values) as a cells values until the last line which includes objects under tests;
	\end{itemize}
	\item \textbf{Expected Return} - column must be next after invocation line.
	\item All functions under test should be asynchronous and accept callback as a last input parameter with standard signature for handling emitted event;
	\item References to the columns with expected return values will accept as value the value obtained from the method execution;
	\item References must be defined only to cells in one of the previous rows;
	\item Files extensions must be xlsx.
\end{itemize}

\chapter{Implementation}
\label{chap:implementation}
For the description of data structures processed by the system, we will use following module (Listing: \ref{demo}) which implements a stack with asynchronous methods (respond time for each method is delayed 10 milliseconds). Usage of the \textit{setTimeout()} method guarantees its asynchronism. While the fact that the timeframe for the response is hard coded into scraping scripts ensures that this method is valid for usage as a proof of concept within the current research topic.
\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={stack.js},
captionpos=b,
label=demo
]
{code/demo/stack.js.txt}
The Test Sheet for test coverage of this module looks as following (Figure: \ref{fig:demoTS}). Note that this test coverage was made for the  purpose to show handling of asynchronous testing of real-time software but not to cover the stack module. There are both types of comparison in invocation lines (Column \textbf{D}). The red arrows indicate the references withing this test sheet.
\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{grafiken/demoTS.pdf}
\caption{Test Sheet coverage for stack.js}
\label{fig:demoTS}
\end{figure}


For the reading of the content from the spread sheet and transforming obtained information into javascript code with further writing of it into a js file the system uses following dependencies upon external npm packages:
\begin{itemize}
	\item Development dependencies:
	\begin{itemize}
		\item  "fs-readdir": "0.0.3", (\url{https://www.npmjs.com/package/fs-readdir});
		\item "through2": "2.0.0", (\url{https://www.npmjs.com/package/through2});
		\item "xlsx": "0.8.0", (\url{https://www.npmjs.com/package/xlsx});
		\item "multipipe": "0.3.1", (\url{https://www.npmjs.com/package/multipipe})
	\end{itemize}
	\item Testing dependencies:
	\begin{itemize}
		\item "mocha": "2.3.4", (\url{https://www.npmjs.com/package/mocha})
		\item "sinon": "1.17.2", (\url{https://www.npmjs.com/package/sinon})
	\end{itemize}
\end{itemize}

\section{Read Stream}
\label{sec:read}
This part of the system is an implementation of combining streams pattern. From the internal view, it consists of two streams.  The first stream is implemented with the use  \textbf{getFilesStream} function. It creates readable stream for reading content of directory including nested directories and returns the array with absolute paths to them.
Second stream is \textbf{getDataStream} the stream in an object mode. For every file path, it accepts from the down stream, it checks its extensions and if it is equal to .xlsx this stream implements the reading content of files. For this purpose it uses \textit{xlsx} module and  \textit{fs}  to read meta data of the file. Next, this stream pushes obtained data to the up stream (Listing: \ref{readStream}).
 
\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={read\_stream.js},
captionpos=b,
label=readStream
]
{code/lib/stream/readStream.js.txt}

These two streams are piped into combined stream using module \textit{multipipe} and returned by the function exported by this module.
In other words, this module exports function which accepts path to the directory and returns array of deferred values to the upstream. Each of deferred value  is a javascript object with following structure (Listing \ref{readOut})
\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={Read Stream Output  / Transform Stream Input JSON},
captionpos=b,
label=readOut
]
{code/readOut.js.txt}

\subsection{Test Coverage}
Following test cases show step every incrementally performed during the development process. All calls to systems I/O (e. g. read file meta data, read file) are implemented using stubs. \textbf{Stub} is an implementation of \textit{proxy pattern} which allows to redefine functions behavior. This gives an opportunity to improve speed of tests by replacing functions with call to I/O with empty functions.
%\lstinputlisting[
%language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
%basicstyle=\footnotesize,
%numberstyle=\tiny,
%caption={Test coverage for read\_stream.js},
%captionpos=b,
%label=readTest
%]
%{code/test/readStream.js.txt}

The result of tests execution  for this module is following (Fig.: \ref{fig:testRead}):
\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{grafiken/testReadStream.png}
	\caption{Test coverage for read\_stream.js}
	\label{fig:testRead}
\end{figure}



\subsection{Correspondence to the design principles}
\begin{itemize}
	\item Closing - the part of the code responsible for the reading content of the file with the concrete extension and the concrete structure is encapsulated with \textit{getDataStream} function
	\item Code to an Interface - no references to any classes;%the communication is done via standard stream interface.
	\item Do not repeat yourself - no code duplication;
	\item The Single-Responsibility Principle - % can be changed only due to the introduction of new requirements for support multiple sheets within the one xlsx file;
	\item The Open/Closed Principle - functionality of the library can be extended via adding new pipes with application of different piping patterns in a single place;
	\item The Liskov Substitution Principle - object composition is used over inheritance (function wrapped in to pipe object);
	\item The Dependency-Inversion Principle - communication with other modules is done via standard interface.
		\begin{itemize}
			\item Higher level module \textit{index.js} does not depend on implementation current library
			\item Current library depends on the input type provided by the \textit{index.js}
		\end{itemize}
	\item The Interface Segregation Principle - composition over inheritance and usage of standard interfaces;
	\item Principles of Least Knowledge - communication done only with \textit{xlsx} files;
	\item The Principle of Loose Coupling - communication is done via standard file system and standard stream interfaces.
\end{itemize}
%\begin{itemize}
%	\item Closing - stream is closed over file extension, schema\_maker - object structure returned by 	\textit{xlsx} library;
%	\item Code to Interface - stream obtains and returns values via standard stream interface, call to file system made via standard nodeJS File System stream interface;
%	\item Do not Repeat Yourself - no code duplication;
%	\item Single Responsibility Principle - can be changed only due to the change of input type;
%	\item Open Close Principle - new pipes can be added in a single place;
%	\item Liscov Substitution Principle - no inherited objects used;
%	\item Interface Segregation Principle - no dependency on redundant methods;
%	\item Dependency Inversion Principle - higher level module index.js does not depend on current library
%	\item Least Knowledge Principle - communication to interfaces and invocation of used library;
%	\item Loose Coupling Principle - standard interfaces;
%\end{itemize}
%
%\textbf{Design principles implication:}
%\begin{itemize}
%\item  S. - Single Responsibility Principle - can be changed only due to the change of input type
%\item  O. - Open Close Principle - new pipes can be added in a single place
%\item  L. - Liscov Substitution Principle - no inheritance
%\item  I. - Interface Segregation Principle - Stream interface / File System interface
%\item  D. - Dependency Inversion Principle - Higgher level module index.js does not depend on current library
%
%Writer structure:\\


\section{Transform Stream}
\label{sec:transform}
This part of the system performs translation of the Test Sheet into executable javascript code. In this realization of the Test Sheet concept translation performed in four stages. 


\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={Transform Stream},
captionpos=b,
label=writeIn
]
{code/lib/stream/transformStream.js.txt}

The\textbf{ first stage} is a creation of \textit{schema} object of the Test Sheet. The \textbf{second stage} is the definition of the execution order. The \textbf{third stage} is mapping schema object from the first step to execution order array from the second step. The last, \textbf{forth stage} is an application of a template to the content of Test Sheet and the execution schema which has been created on a previous stage. The result of this transformation is pulled by the upstream as a \textit{content} property of an object together with \textit{meta data} and \textit{fileName} obtained from the downstream (Listing: \ref{writeIn}).

\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={Transform Stream Output / Write Stream Input JSON},
captionpos=b,
label=writeIn
]
{code/writeIn.js.txt}

\subsection{Test Coverage}
Following test cases can show every step incrementally performed during the development process. Including invocations of helper methods from \textit{scheme} and \textit{template} modules.
%\lstinputlisting[
%language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
%basicstyle=\footnotesize,
%numberstyle=\tiny,
%caption={Test coverage for transform\_stream.js },
%captionpos=b,
%label=writeIn
%]
%{code/lib/stream/transformStream.js.txt}

The result of test execution:
\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{grafiken/testTransform.png}
	\caption{Test coverage for transform\_stream.js}
	\label{fig:testTransofm}
\end{figure}

\subsection{Correspondence to the design principles}
\begin{itemize}
	\item Closing - the creation of data structure to be transformed to the next stream is created in a single function;
	\item Code to an Interface - this module does not refer to any class. 
	\item Do not repeat yourself - no code duplication;
	\item The Single-Responsibility Principle - can be changed only due to the change of Test Sheet type (another type of scheme);
	\item The Open/Closed Principle - new pipes can be added in a single place with adding new functions to be wrapped in them;
	\item The Liskov Substitution Principle - object composition over inheritance (function wrapped in to pipe object);
	\item The Dependency-Inversion Principle - 
				\begin{itemize}
					\item Higher level module \textit{index.js} does not depend on implementation current library;
					\item Current library depends on the input object provided by the previous stream;
				\end{itemize}
	\item The Interface Segregation Principle -  does not depend on methods since it only creates data object to be passed to the next stream;
	\item Principles of Least Knowledge - direct communication done only with helper functions for schema creation and content generation. 
	\item The Principle of Loose Coupling - communication is done via the standard stream interface
\end{itemize}


\section{Scheme}
\label{sec:scheme}
This part of the system creates a scheme object from the Test Sheet, the only parameter accepted by the main function of this module is a Test Sheet object (the content of xlsx file in a JSON format).
%The decision to perform scheme creation in two stages was made due to the structure of the input object.

The \textbf{first stage} is creation of the object with following properties:
\begin{enumerate}
	\item description;
	\item moduleUnderTest;
	\item objectsUnderTest;
	\item methodsUnderTest;
	\item inputs;
	\item invocations;
	\item outputs;
\end{enumerate}

 The values of each property except \textit{description} and \textit{moduleUnderTest} are arrays of strings with values which represent cell addresses for representative property of the Test Sheet. For the first two properties the values are strings with data  from the cells \textit{A1} and \textit{A2} respectively(Listing: \ref{firstScheme}).

\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={Result of the first stage of Test Sheet scheme creation},
captionpos=b,
label=firstScheme
]
{code/firstSchema.js.txt}

The \textbf{sectod stage} is a pivot transformation of the scheme provided from the previous stage. The output of this transformation is an object with properties as a numbers of rows in the Test Sheet object. The values for first and second properties are values of \textit{description} and \textit{module} under test from the respective Test Sheet. While next of them are objects which consist of following Test Sheet properties: \textit{objectUnderTest, methodUnderTest, inputs, outputs, invocations}. With values as single element arrays with coordinate of respective cell (Listing \ref{scheme}).
\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={Result of the scheme creation  for Test Sheet},
captionpos=b,
label=scheme
]
{code/scheme.js.txt}

%\lstinputlisting[
%language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
%basicstyle=\footnotesize,
%numberstyle=\tiny,
%caption={Module for creation of the Test Sheet scheme},
%captionpos=b,
%label=writeIn
%]
%{code/lib/scheme/index.js.txt}
\subsection{Test Coverage}
Following test cases can show every step incrementally performed during the development process. Since the object obtained from the reading of xlsx file is passed from one part of the system to another (\textit{Object pool OOP pattern}) this module does not perform any I/O calls. There are getter function for each type of cell in a Test Sheet as well as pivot function called \textit{transformScheme} and helper for it called \textit{getRowFromField}.
%\lstinputlisting[
%language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
%basicstyle=\footnotesize,
%numberstyle=\tiny,
%caption={Test coverage for creation of the Test Sheet scheme},
%captionpos=b,
%label=writeIn
%]
%{code/test/scheme.js.txt}

The result of test execution:
\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{grafiken/testScheme.png}
	\caption{Test coverage for scheme.js}
	\label{fig:testScheme}
\end{figure}

\subsection{Correspondence to the  design principles}
\begin{itemize}
	\item Closing - comparison type is closed within the \textit{getInvocationCells} function, all elements of Test Sheet are obtained via separate getter functions;
	\item Code to an Interface - all methods have the same minimal abstraction layer for object which represents the content of Test Sheet. All keys of the object should be named as a two dimensional addresses of the cells (i. e. \textit{A1}, \textit{D7} etc);
	\item Do not repeat yourself - no code repetition.
	\item The Single-Responsibility Principle - \textit{transformScheme} function should be changed in case of introduction of the non-linear Test Sheets, since this type has behavior definition in rows under test steps;
	\item The Open/Closed Principle - violated in a \textit{transformScheme} function;
	\item The Liskov Substitution Principle - no inheritance.
	\item The Dependency-Inversion Principle - does not have any lower level modules;
	\item The Interface Segregation Principle - does not have any lower level modules;
	\item Principles of Least Knowledge - can be invoked only via direct import;
	\item The Principle of Loose Coupling - exports single function;
\end{itemize}

\section{Execution Order}
\label{sec:execOrder}
This part of the system is responsible for the definition of an order for the test steps execution. In a general case, the execution order of tests for a Basic Test Sheet is defined by the order of test steps. 
All Test Sheets support references it provides an ability to define input for one test step as an output of some of the previous steps.


However, in \textit{asynchronous} software the moment when execution is completed comes after the period of time when the next function can invoked. Moreover, \textit{real-time} systems have time constraints on their execution, but do not provide an exact time within it will be completed. Further, due to the requirements for the generated tests proposed by figo GmbH test execution should be fast since it will be performed in a timely fashion. Combination of this factors forced to define moment of each test step execution with respect to the source of their input parameters.


For the definition of test steps execution order the decision was taken is to separate test steps in two types. \textit{The first} type covers test steps which behavior does not make influence to the next steps (do not define input parameters for further test steps) and is not determined by any of previous test steps. \textit{The second} type covers test steps which execution result determines behavior of the next test steps or is defined by previous steps.

%
% But the fact that in this case Basic Test Sheets are applied  for \textit{asynchronous} testing of \textit{real-time} software together with an ability to 
%This shit is important for application for real time software.
The process of order definition is following. Main function accepts two input parameters: \textit{sheet} - the content of xlsx file which defines the Test Sheet and \textit{scheme} - the object generated by the main function from \textit{scheme.js} file (Listing: \ref{order}). Walking through the scheme elements starting with the third (skipping service rows) performs the check for each cell in a sheet object for determining does behavior of test step define inputs of any next test step. In this case such test step will be pushed to the \textit{chain} array as the first element and all dependent test steps will be pushed to the nested array as a list of dependent test steps. If \textit{chain} is not empty it will be pushed to the global (in a function scope) \textit{chains}  array. All other rows will be pushed to the \textit{linear array}.


\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={Generation of tree structure as a list of childnodes},
captionpos=b,
label=order
]
{code/order.js.txt}

For the further creation of test steps execution order the list of child nodes should be merged into nested list for child nodes which has other child nodes. In terms of test steps this means that the result one test step can define the behavior of few next steps either directly or via some intermediate test steps. 
The merging process is performed by the \textit{transformation} function (Listing \ref{transformation}). It accepts an array object (\textit{chains} array described previously) and performs iterative walk through with recursive call for each nested array. During each iteration this function checks the values of childes (nested arrays) for each of them being a parent for other child nodes (is it present as a first element in next arrays). In such case it takes list of its child nodes and creates a two dimensional array which replaces the the parent element in a list of childes with removing parent entry together with its child nodes from the current position. This operation of replacement performed recursively through all nested arrays using \textit{isIn} function which determines if given element belongs to the provided array including nested arrays.

\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={Generation of nested data structure},
captionpos=b,
label=transformation
]
{code/transformFunction.js.txt}

The final step is the  concatenation of arrays from the \textit{first} and the \textit{second} test steps types. In this example, rows \textit{one} and \textit{two} belong to the first type as a service rows which do not define any test steps together with rows \textit{three} and \textit{four}. Note that the input parameter for the test step defined in a row number four is referenced by the expected output of the test step that was defined in a row five. However, the input parameter can not be changed by the execution process of test step and can be passed to the next step before the execution starts without any logic violation. At the same time result of test step \textit{five} is an input parameter for the steps \textit{six}, \textit{seven} and \textit{ten} this in turn defines an input for the test step \textit{eleven} (Listing: \ref{orderSteps}).
\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={Execution order},
captionpos=b,
label=orderSteps
]
{code/executionOrderSchema.js.txt}


\subsection{Test coverage}

The following test cases can show every step incrementally performed during the development process. Here you also can see application of Object pool pattern which helped to get rid of the call to I/O for the process of reading content from the .xlsx file.
\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{grafiken/testOrder.png}
	\caption{Test coverage for order.js}
	\label{fig:testOrder}
\end{figure}

\subsection{Correspondence to  the design principles}
\begin{itemize}
	\item Closing - nothing is likely to change;
	\item Code to an Interface - exports a single function;
	\item Do not repeat yourself - no code duplication;
	\item The Single-Responsibility Principle - can be changed only because of the introduction of new types of the Test Sheets;
	\item The Open/Closed Principle - no reason to change, no need for a new functionality;
	\item The Liskov Substitution Principle - no inheritance;
	\item The Dependency-Inversion Principle - does not have any lower level modules;
	\item The Interface Segregation Principle - does not have any lower level modules;
	\item Principles of Least Knowledge -  can be invoked only via direct import;
	\item The Principle of Loose Coupling - exports a single function.
\end{itemize}

\section{Execution Scheme}
\label{sec:execScheme}
This step performs the recursive replacement of elements in an \textit{execution order} array with the elements from the \textit{scheme} object. The function (Listing: \ref{execScheme}) accepts two arguments: \textit{scheme} object and \textit{order} array. If an element is of an input array is an array it then performs recursive call.

\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={Application of execution order to the scheme},
captionpos=b,
label=execScheme
]
{code/executionSchema.js.txt}
\subsection{Test Coverage}
Following test cases can show each step incrementally performed during the development process.
\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{grafiken/testCreate.png}
	\caption{Test coverage for creation of execution scheme}
	\label{fig:testCreate}
\end{figure}

\subsection{Correspondence to the design principles}
\begin{itemize}
	\item Closing - nothing is likely to change;
	\item Code to an Interface - exports a single function;
	\item Do not repeat yourself - no code duplication;
	\item The Single-Responsibility Principle - nothing is likely to change;
	\item The Open/Closed Principle - no reason to add/change the functionality;
	\item The Liskov Substitution Principle - no inheritance;
	\item The Dependency-Inversion Principle - does not have any lower level modules;
	\item The Interface Segregation Principle - does not have any lower level modules;
	\item Principles of Least Knowledge -  can be invoked only via direct import;
	\item The Principle of Loose Coupling - exports a single function.
\end{itemize}

\section{Template}
\label{sec:template}
The translation to executable javascript file is made by the application of the \textit{template} function. This function accepts three parameters \textit{sheet $<$Object$>$, scheme $<$Object$>$, fileName$<$String$>$}. \textit{Sheet} is a javascript object returned by reading the content of Test Sheet file. The \textit{scheme} is an execution order scheme. The \textit{fileName} is a path to the TestSheet file. This function creates a string content for javascript file based on provided parameters. This function also make indentation and formating of generated file content. The creation takes part in a four stages. 


The \textbf{first stage} is adding a description from the first element of the scheme object. It is enclosed within the multiline comment symbols.


The \textbf{second stage} is adding require of reporting module for representation of execution of the tests result.


The \textbf{third stage} is adding declarations of the module scope variables. The variable names are taken from the coordinates of cells which store input and output parameters in a Test Sheet. The values of the variables are taken from the cells with respective addresses.


The \textbf{fourth stage} is adding calls to the methods (Listing: \ref{applyTemplate}). This stage is the most important part of this module. Since there are two types of execution orders adding function calls is performed in two steps described below. 


The \textit{\textbf{first step}} is adding calls for independent test steps. This is made by iterative call of the \textit{makeCall} function with appending closing brackets to the end of the result string during each of iterations. This function simply performs mapping between \textit{sheet} object (content of xlsx file), \textit{scheme} entry (test step) and string with the content for executable javascript file (Listing: \ref{makeCall}).

\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={Function makeCall from template module},
captionpos=b,
label=makeCall
]
{code/makeCall.js.txt}

Note that functions in the generated code are not called directly but via the \textit{call} method of the function's prototype. This method provides an opportunity to call the function from the different context (environment). In the current example the implementation of \textit{stack} module does not depend on the environment in which it was called. But in some cases the result of function's invocation can depend on the environment in which it was invoked. One of such cases can be the creation of child process. The environment for such calls should be passed as an \textit{object under test}.


The \textit{\textbf{second step}} is adding calls for interdependent test steps. For every  element of the \textit{nestedCalls} array it calls the  \textit{makeNestedCall} function and if the next element is an array then this function performs recursive call with an appending of the closing brackets to the result of this call. In case if next element is not an array the it appends closing brackets and performs next iteration (Listing: {\ref{applyTemplate}).



\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={Function applyTemplate from template module},
captionpos=b,
label=applyTemplate
]
{code/apply_template.js.txt}


%
%It is implemented as \textit{addCalls} function. This is recursive function which accepts four parameter: \textit{sheet, scheme, indentation, accumulator, fileName}. First two parameters are necessary to access the values represented in a Test Sheet. Next parameter is an indentation level which represents the deepness of a function call by adding representative amount of spaces for each line of generated code. Accumulator parameter is a string to which will be appended result of each recursive call of the function. The last parameter is necessary for report mechanism which allows to record result of the test execution to appropriate file. The report mechanism (e.g \textit{makeComparisonAndWriteResult}) will be described in details within  the next section. However it is important to mention here how it works as a 'black box'. It is binary function which accepts  six parameters. First parameter is an expected return value. Second is an actual returned value received by the callback function, third is a deepness of comparison will be performed for this their values. The function returns \textbf{true} in case of match and after redefinition of the variable takes place. This mechanism allows usage of references within the Test Sheet for asynchronous functions.
%\lstinputlisting[
%language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
%basicstyle=\footnotesize,
%numberstyle=\tiny,
%caption={Function addCalls from template module},
%captionpos=b,
%label=template
%]
%{code/lib/template/template.js.txt}


The general case signature for function call generated from this template is following (Listing \ref{gentemplate}):
\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={Signature for generated function call},
captionpos=b,
label=gentemplate
]
{code/GeneralTemplate.js.txt}

\subsection{Test Coverage}
Following test cases can show each step incrementally performed during the development process.

%\lstinputlisting[
%language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
%basicstyle=\footnotesize,
%numberstyle=\tiny,
%caption={Test coverage for creation of the Test Sheet template},
%captionpos=b,
%label=writeIn
%]
%{code/test/template.js.txt}

The result of test execution:
\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{grafiken/testTemplate.png}
	\caption{Test coverage for template.js}
	\label{fig:testTemplate}
\end{figure}

\subsection{Correspondence to the design principles}
\begin{itemize}
	\item Closing - content generation is enclosed within three independent functions;
	\item Code to an Interface - exports a single function;
	\item Do not repeat yourself - no code duplication;
	\item The Single-Responsibility Principle - can be changed only due to the requirements for generated code;
	\item The Open/Closed Principle - no need to be changed, new functionality can be added via implementation of new version for the \textit{makeCall} function;
	\item The Liskov Substitution Principle - no inheritance;
	\item The Dependency-Inversion Principle - does not have any lower level dependencies;
	\item The Interface Segregation Principle - composition over inheritance;
	\item Principles of Least Knowledge - can be invoked only via direct import;
	\item The Principle of Loose Coupling - exports a single function.
\end{itemize}

e\section{Write Stream}
\label{sec:write}
This part of the system implements on function and exports it wrapped into object stream. It receives an object from the down with the following structure (Listing: \ref{writeIn}). It tries to read meta-data of the file with same name as Test Sheet file but with the .js extension, it is possible only if the file exists. In other case, the exception will be thrown and caught by the \textit{ catch} block which implements the creation of the file with the content received from the down stream. If the file is already exists then the function will be able to read its meta-data. After it, this meta-data will be compared with meta-data of the Test Sheet file received from the down stream. In case if the modification date of the Test Sheet file is bigger then the modification data of the  .js file then the system will overwrite the content of the javascript file with the content that was received from the down stream. In case when the Tests Sheet file was not updated after the creation of the representative js file the system will switch to the next object received from the upstream. The result javascript file generated from the provided Test Sheet looks as following (Listing: \ref{demo})

\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={Generated javascript file},
captionpos=b,
label=demo
]
{code/demo/demo.js.txt}

%\lstinputlisting[
%language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
%basicstyle=\footnotesize,
%numberstyle=\tiny,
%caption={write\_stream.js},
%captionpos=b,
%label=demo
%]
%{code/lib/stream/writeStream.js.txt}

\subsection{Test Coverage}
The following test cases can show each step incrementally performed during the development process. All calls to systems I/O (e. g. read file meta data, read file) are implemented using stubs.
%\lstinputlisting[
%language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
%basicstyle=\footnotesize,
%numberstyle=\tiny,
%caption={Test coverage for write\_stream.js},
%captionpos=b,
%label=writeTest
%]
%{code/test/writeStream.js.txt}


The result of tests execution  for this module is following (Fig.: \ref{fig:testWrite}): 
\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{grafiken/testWriteStream.png}
	\caption{Test coverage for write\_stream.js}
	\label{fig:testWrite}
\end{figure}

\subsection{Correspondence to the design principles}
\begin{itemize}
	\item Closing - module exports the single stream object with the wrapped function.
	\item Code to an Interface - calls are done to the public functions of the required objects. 
	\item Do not repeat yourself - small code duplication in callbacks for file writing, while avoiding this will add more complexity;
	\item The Single-Responsibility Principle - can be changed due to the introduction of requirements for support of multiple sheets within the single xlsx file.
	\item The Open/Closed Principle - performs writing to the file only;
	\item The Liskov Substitution Principle - no inheritance;
	\item The Dependency-Inversion Principle - 
	\begin{itemize}
		\item The Higher level module \textit{index.js} does not depend on implementation current library
		\item Current library depends on the input type provided by the \textit{index.js}
	\end{itemize}
	\item The Interface Segregation Principle - no calls of unnecessary methods;
	\item Principles of Least Knowledge - communication done only with js files;
	\item The Principle of Loose Coupling - communication is done via standard file system and standard stream interfaces.
\end{itemize}

\section{Reporting mechanism}
\label{sec:report}
The reporting mechanism made as a standalone npm package which must be installed globally. This is necessary for an ability to be called by generated javascript files described in a previous section. Since they can be located in different parts of the system. 
The folder/file structure of the application looks as following:
\begin{itemize}
	\item index.js
	\item package.json
	\item ReadMe.md
	\item lib/
	\begin{itemize}
		\item compare\_and\_write.js
	\end{itemize}
	\item test/
	\begin{itemize}
		\item compare\_and\_write.js
	\end{itemize}
	\item node\_modules/
\end{itemize}

\subsection{Implementation}
The system has following dependencies upon external npm packages:
\begin{itemize}
	\item Development dependencies:
	\begin{itemize}
		\item "xlsx": "0.8.0", (\url{https://www.npmjs.com/package/xlsx})
	\end{itemize}
	\item Testing dependencies:
	\begin{itemize}
		\item "mocha": "2.3.4", (\url{https://www.npmjs.com/package/mocha})
		\item "sinon": "1.17.2", (\url{https://www.npmjs.com/package/sinon})
	\end{itemize}
\end{itemize}
	

\lstinputlisting[
language=Javascript, numbers=left, stepnumber=5, firstnumber=1, breaklines=true, 
basicstyle=\footnotesize,
numberstyle=\tiny,
caption={Report mechanism's main function},
captionpos=b,
label=report
]
{code/report.js.txt}

On Figure \ref{fig:resultTestSheet} you see the result Test Sheet created after execution of the generated demo.js file. Note that on line 10 the \textit{pop} method returns value \textit{\{"el": 1 \}} but not the \textit{\{ "el": 5 \}}. This is correct behavior since all the operations are asynchronous and test step 10 does not depend on test step 9. The implementation described in this paper does not guarantee sequential execution of independent test steps. As was already said, this is done for optimization reasons, so that test steps which do not depend upon each other can be started for the execution without waiting for previous step execution being completed. 
\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{grafiken/testSheetResult.png}
	\caption{Result Test Sheet for stack.js}
	\label{fig:resultTestSheet}
\end{figure}


\subsection{Test coverage}
The following test cases can show each step incrementally performed during the development process. All calls to systems I/O (e. g. read file meta data, read file) are implemented using stubs.
The result of tests execution  for this module is following (Fig.: \ref{fig:testReport}): 
\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{grafiken/testReport.png}
	\caption{Test coverage for report mechanism}
	\label{fig:testReport}
\end{figure}

\subsection{Correspondence to the  design principles}
\begin{itemize}
	\item Closing - comparison and reporting processes done in the different independent functions;
	\item Code to an Interface - exports a single function;
	\item Do not repeat yourself - no code duplication;
	\item The Single-Responsibility Principle - can be changed only due to the reporting media;
	\item The Open/Closed Principle - new functionality can be added as another exported function;
	\item The Liskov Substitution Principle - no inheritance (required as an npm package);
	\item The Dependency-Inversion Principle - requires standard \textit{assert}, \textit{files system} modules and \textit{xlsx} module;
	\item The Interface Segregation Principle - does not have any lower level modules;
	\item Principles of Least Knowledge -  can be invoked only via the  direct import;
	\item The Principle of Loose Coupling - exports a single function.
\end{itemize}